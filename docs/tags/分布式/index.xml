<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>分布式 on Huija&#39;s Blog</title>
    <link>https://huija.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/</link>
    <description>Recent content in 分布式 on Huija&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 07 May 2021 13:37:16 +0800</lastBuildDate><atom:link href="https://huija.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MongoDB复制集</title>
      <link>https://huija.github.io/mongodb-replicaset/</link>
      <pubDate>Fri, 07 May 2021 13:37:16 +0800</pubDate>
      
      <guid>https://huija.github.io/mongodb-replicaset/</guid>
      <description>MongoDB复制集 MongoDB复制集是MongoDB分布式系统的核心.
 mongodb的api对于单点,复制集,分片集群都通用的, 这也就意味着, 改变底层架构, 对于代码基本无需改动.
 浅谈复制集 先撇开MongoDB单独来讲复制集群, 顾名思义, 就是从原先的机器复制一份, 一起部署, 在分布式场景是很常见的部署架构, 以数据库们为例, 就有MySQL基于binlog的主从部署, PostgreSQL基于WAL日志的同步/异步流复制, Redis的主从复制等.
复制集的意义  复制集本身, 解决的根本问题是, 单机部署的单点故障问题, 当主节点挂掉, 可以转正从节点, 也就是数据冗余以及高可用. 衍生出来的, 是可以进行读写分流, 并针对读的流量进行横向扩展, 也就是可伸缩性与负载均衡.  复制集的问题 复制集的最核心的问题集中于消息从主节点到从节点的备份策略, 同步还是异步
 如果同步备份, 那么会保证每个操作后, 主从的数据都是一致的, 也就是强一致性, 但是如果从节点挂了, 使用同步的策略, 那主节点的请求是否要返回失败, 这就涉及可用性的问题. 一般数据库的主流策略都是异步, 不追求数据的强一致性, 而是最终一致性, 重点保证可用性, 而实时性问题, 则通过一定手段进行避免.  MongoDB复制集 MongoDB的主从叫Primary和Secondary, 其复制集由一个Primary和多个Secondary组成, Primary可以进行读写操作, Secondary回放Primary发送的oplog, 进行数据备份.
 还有一种节点类型, 叫Arbiter, 仲裁者, 其主要负责选举投票, 而不进行数据备份, 也不能竞选Primary.
 典型的三节点部署 主节点的选举条件是需要半数以上的投票节点投票, 一般节点数量都会设置为单数, 也就是2n+1, 最多支持挂掉n个节点, 集群仍然能正常工作, 与2(n+1)个节点能够容忍的数量是一样的, 所以一般节点数(具有投票权)都是单数</description>
    </item>
    
  </channel>
</rss>
